// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PSIPARAMS_APSI_FBS_H_
#define FLATBUFFERS_GENERATED_PSIPARAMS_APSI_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace apsi {
namespace fbs {

struct ItemParams;

struct TableParams;

struct QueryParams;
struct QueryParamsBuilder;

struct SEALParams;
struct SEALParamsBuilder;

struct PSIParams;
struct PSIParamsBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ItemParams FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t felts_per_item_;

 public:
  ItemParams()
      : felts_per_item_(0) {
  }
  ItemParams(uint32_t _felts_per_item)
      : felts_per_item_(flatbuffers::EndianScalar(_felts_per_item)) {
  }
  uint32_t felts_per_item() const {
    return flatbuffers::EndianScalar(felts_per_item_);
  }
};
FLATBUFFERS_STRUCT_END(ItemParams, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TableParams FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t table_size_;
  uint32_t max_items_per_bin_;
  uint32_t hash_func_count_;

 public:
  TableParams()
      : table_size_(0),
        max_items_per_bin_(0),
        hash_func_count_(0) {
  }
  TableParams(uint32_t _table_size, uint32_t _max_items_per_bin, uint32_t _hash_func_count)
      : table_size_(flatbuffers::EndianScalar(_table_size)),
        max_items_per_bin_(flatbuffers::EndianScalar(_max_items_per_bin)),
        hash_func_count_(flatbuffers::EndianScalar(_hash_func_count)) {
  }
  uint32_t table_size() const {
    return flatbuffers::EndianScalar(table_size_);
  }
  uint32_t max_items_per_bin() const {
    return flatbuffers::EndianScalar(max_items_per_bin_);
  }
  uint32_t hash_func_count() const {
    return flatbuffers::EndianScalar(hash_func_count_);
  }
};
FLATBUFFERS_STRUCT_END(TableParams, 12);

struct QueryParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QueryParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PS_LOW_DEGREE = 4,
    VT_QUERY_POWERS = 6
  };
  uint32_t ps_low_degree() const {
    return GetField<uint32_t>(VT_PS_LOW_DEGREE, 0);
  }
  const flatbuffers::Vector<uint32_t> *query_powers() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_QUERY_POWERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PS_LOW_DEGREE) &&
           VerifyOffset(verifier, VT_QUERY_POWERS) &&
           verifier.VerifyVector(query_powers()) &&
           verifier.EndTable();
  }
};

struct QueryParamsBuilder {
  typedef QueryParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ps_low_degree(uint32_t ps_low_degree) {
    fbb_.AddElement<uint32_t>(QueryParams::VT_PS_LOW_DEGREE, ps_low_degree, 0);
  }
  void add_query_powers(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> query_powers) {
    fbb_.AddOffset(QueryParams::VT_QUERY_POWERS, query_powers);
  }
  explicit QueryParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QueryParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryParams> CreateQueryParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ps_low_degree = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> query_powers = 0) {
  QueryParamsBuilder builder_(_fbb);
  builder_.add_query_powers(query_powers);
  builder_.add_ps_low_degree(ps_low_degree);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryParams> CreateQueryParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ps_low_degree = 0,
    const std::vector<uint32_t> *query_powers = nullptr) {
  auto query_powers__ = query_powers ? _fbb.CreateVector<uint32_t>(*query_powers) : 0;
  return apsi::fbs::CreateQueryParams(
      _fbb,
      ps_low_degree,
      query_powers__);
}

struct SEALParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SEALParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct SEALParamsBuilder {
  typedef SEALParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(SEALParams::VT_DATA, data);
  }
  explicit SEALParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SEALParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SEALParams>(end);
    fbb_.Required(o, SEALParams::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<SEALParams> CreateSEALParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  SEALParamsBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<SEALParams> CreateSEALParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return apsi::fbs::CreateSEALParams(
      _fbb,
      data__);
}

struct PSIParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PSIParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_ITEM_PARAMS = 6,
    VT_TABLE_PARAMS = 8,
    VT_QUERY_PARAMS = 10,
    VT_SEAL_PARAMS = 12
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const apsi::fbs::ItemParams *item_params() const {
    return GetStruct<const apsi::fbs::ItemParams *>(VT_ITEM_PARAMS);
  }
  const apsi::fbs::TableParams *table_params() const {
    return GetStruct<const apsi::fbs::TableParams *>(VT_TABLE_PARAMS);
  }
  const apsi::fbs::QueryParams *query_params() const {
    return GetPointer<const apsi::fbs::QueryParams *>(VT_QUERY_PARAMS);
  }
  const apsi::fbs::SEALParams *seal_params() const {
    return GetPointer<const apsi::fbs::SEALParams *>(VT_SEAL_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<apsi::fbs::ItemParams>(verifier, VT_ITEM_PARAMS) &&
           VerifyField<apsi::fbs::TableParams>(verifier, VT_TABLE_PARAMS) &&
           VerifyOffset(verifier, VT_QUERY_PARAMS) &&
           verifier.VerifyTable(query_params()) &&
           VerifyOffsetRequired(verifier, VT_SEAL_PARAMS) &&
           verifier.VerifyTable(seal_params()) &&
           verifier.EndTable();
  }
};

struct PSIParamsBuilder {
  typedef PSIParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(PSIParams::VT_VERSION, version, 0);
  }
  void add_item_params(const apsi::fbs::ItemParams *item_params) {
    fbb_.AddStruct(PSIParams::VT_ITEM_PARAMS, item_params);
  }
  void add_table_params(const apsi::fbs::TableParams *table_params) {
    fbb_.AddStruct(PSIParams::VT_TABLE_PARAMS, table_params);
  }
  void add_query_params(flatbuffers::Offset<apsi::fbs::QueryParams> query_params) {
    fbb_.AddOffset(PSIParams::VT_QUERY_PARAMS, query_params);
  }
  void add_seal_params(flatbuffers::Offset<apsi::fbs::SEALParams> seal_params) {
    fbb_.AddOffset(PSIParams::VT_SEAL_PARAMS, seal_params);
  }
  explicit PSIParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PSIParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PSIParams>(end);
    fbb_.Required(o, PSIParams::VT_SEAL_PARAMS);
    return o;
  }
};

inline flatbuffers::Offset<PSIParams> CreatePSIParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const apsi::fbs::ItemParams *item_params = 0,
    const apsi::fbs::TableParams *table_params = 0,
    flatbuffers::Offset<apsi::fbs::QueryParams> query_params = 0,
    flatbuffers::Offset<apsi::fbs::SEALParams> seal_params = 0) {
  PSIParamsBuilder builder_(_fbb);
  builder_.add_seal_params(seal_params);
  builder_.add_query_params(query_params);
  builder_.add_table_params(table_params);
  builder_.add_item_params(item_params);
  builder_.add_version(version);
  return builder_.Finish();
}

inline const apsi::fbs::PSIParams *GetPSIParams(const void *buf) {
  return flatbuffers::GetRoot<apsi::fbs::PSIParams>(buf);
}

inline const apsi::fbs::PSIParams *GetSizePrefixedPSIParams(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<apsi::fbs::PSIParams>(buf);
}

inline bool VerifyPSIParamsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<apsi::fbs::PSIParams>(nullptr);
}

inline bool VerifySizePrefixedPSIParamsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<apsi::fbs::PSIParams>(nullptr);
}

inline void FinishPSIParamsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<apsi::fbs::PSIParams> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPSIParamsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<apsi::fbs::PSIParams> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace apsi

#endif  // FLATBUFFERS_GENERATED_PSIPARAMS_APSI_FBS_H_
